instrument_list = '''
<GeneralMIDIInstruments>
  <Piano>
    <Instrument program="0">Acoustic Grand Piano</Instrument>
    <Instrument program="1">Bright Acoustic Piano</Instrument>
    <Instrument program="2">Electric Grand Piano</Instrument>
    <Instrument program="4">Electric Piano 1</Instrument>
    <Instrument program="5">Electric Piano 2</Instrument>
    <Instrument program="6">Harpsichord</Instrument>
    <Instrument program="7">Clavinet</Instrument>
  </Piano>
  <ChromaticPercussion>
    <Instrument program="8">Celesta</Instrument>
    <Instrument program="9">Glockenspiel</Instrument>
    <Instrument program="10">Music Box</Instrument>
    <Instrument program="11">Vibraphone</Instrument>
    <Instrument program="12">Marimba</Instrument>
    <Instrument program="13">Xylophone</Instrument>
    <Instrument program="14">Tubular Bells</Instrument>
    <Instrument program="15">Dulcimer</Instrument>
  </ChromaticPercussion>
  <Organ>
    <Instrument program="16">Drawbar Organ</Instrument>
    <Instrument program="17">Percussive Organ</Instrument>
    <Instrument program="18">Rock Organ</Instrument>
    <Instrument program="19">Church Organ</Instrument>
    <Instrument program="20">Reed Organ</Instrument>
    <Instrument program="21">Accordion</Instrument>
    <Instrument program="22">Harmonica</Instrument>
    <Instrument program="23">Tango Accordion</Instrument>
  </Organ>
  <Guitar>
    <Instrument program="24">Acoustic Guitar (nylon)</Instrument>
    <Instrument program="25">Acoustic Guitar (steel)</Instrument>
    <Instrument program="26">Electric Guitar (jazz)</Instrument>
    <Instrument program="27">Electric Guitar (clean)</Instrument>
    <Instrument program="28">Electric Guitar (muted)</Instrument>
    <Instrument program="29">Overdriven Guitar</Instrument>
    <Instrument program="30">Distortion Guitar</Instrument>
    <Instrument program="31">Guitar Harmonics</Instrument>
  </Guitar>
  <Bass>
    <Instrument program="32">Acoustic Bass</Instrument>
    <Instrument program="33">Electric Bass (finger)</Instrument>
    <Instrument program="34">Electric Bass (pick)</Instrument>
    <Instrument program="35">Fretless Bass</Instrument>
    <Instrument program="36">Slap Bass 1</Instrument>
    <Instrument program="37">Slap Bass 2</Instrument>
    <Instrument program="38">Synth Bass 1</Instrument>
    <Instrument program="39">Synth Bass 2</Instrument>
  </Bass>
  <Strings>
    <Instrument program="40">Violin</Instrument>
    <Instrument program="41">Viola</Instrument>
    <Instrument program="42">Cello</Instrument>
    <Instrument program="43">Contrabass</Instrument>
    <Instrument program="44">Tremolo Strings</Instrument>
    <Instrument program="45">Pizzicato Strings</Instrument>
    <Instrument program="46">Orchestral Harp</Instrument>
    <Instrument program="47">Timpani</Instrument>
  </Strings>
  <Ensemble>
    <Instrument program="48">String Ensemble 1</Instrument>
    <Instrument program="49">String Ensemble 2</Instrument>
    <Instrument program="50">SynthStrings 1</Instrument>
    <Instrument program="51">SynthStrings 2</Instrument>
    <Instrument program="52">Choir Aahs</Instrument>
    <Instrument program="53">Voice Oohs</Instrument>
    <Instrument program="54">Synth Voice</Instrument>
    <Instrument program="55">Orchestra Hit</Instrument>
  </Ensemble>
  <Brass>
    <Instrument program="56">Trumpet</Instrument>
    <Instrument program="57">Trombone</Instrument>
    <Instrument program="58">Tuba</Instrument>
    <Instrument program="59">Muted Trumpet</Instrument>
    <Instrument program="60">French Horn</Instrument>
    <Instrument program="61">Brass Section</Instrument>
    <Instrument program="62">SynthBrass 1</Instrument>
    <Instrument program="63">SynthBrass 2</Instrument>
  </Brass>
  <Reed>
    <Instrument program="64">Soprano Sax</Instrument>
    <Instrument program="65">Alto Sax</Instrument>
    <Instrument program="66">Tenor Sax</Instrument>
    <Instrument program="67">Baritone Sax</Instrument>
    <Instrument program="68">Oboe</Instrument>
    <Instrument program="69">English Horn</Instrument>
    <Instrument program="70">Bassoon</Instrument>
    <Instrument program="71">Clarinet</Instrument>
  </Reed>
  <Pipe>
    <Instrument program="72">Piccolo</Instrument>
    <Instrument program="73">Flute</Instrument>
    <Instrument program="74">Recorder</Instrument>
    <Instrument program="75">Pan Flute</Instrument>
    <Instrument program="76">Blown Bottle</Instrument>
    <Instrument program="77">Shakuhachi</Instrument>
    <Instrument program="78">Whistle</Instrument>
    <Instrument program="79">Ocarina</Instrument>
  </Pipe>
  <SynthLead>
    <Instrument program="80">Lead 1 (square)</Instrument>
    <Instrument program="81">Lead 2 (sawtooth)</Instrument>
    <Instrument program="82">Lead 3 (calliope)</Instrument>
    <Instrument program="83">Lead 4 (chiff)</Instrument>
    <Instrument program="84">Lead 5 (charang)</Instrument>
    <Instrument program="85">Lead 6 (voice)</Instrument>
    <Instrument program="86">Lead 7 (fifths)</Instrument>
    <Instrument program="87">Lead 8 (bass + lead)</Instrument>
  </SynthLead>
  <SynthPad>
    <Instrument program="88">Pad 1 (new age)</Instrument>
    <Instrument program="89">Pad 2 (warm)</Instrument>
    <Instrument program="90">Pad 3 (polysynth)</Instrument>
    <Instrument program="91">Pad 4 (choir)</Instrument>
    <Instrument program="92">Pad 5 (bowed)</Instrument>
    <Instrument program="93">Pad 6 (metallic)</Instrument>
    <Instrument program="94">Pad 7 (halo)</Instrument>
    <Instrument program="95">Pad 8 (sweep)</Instrument>
  </SynthPad>
  <SynthEffects>
    <Instrument program="96">FX 1 (rain)</Instrument>
    <Instrument program="97">FX 2 (soundtrack)</Instrument>
    <Instrument program="98">FX 3 (crystal)</Instrument>
    <Instrument program="99">FX 4 (atmosphere)</Instrument>
    <Instrument program="100">FX 5 (brightness)</Instrument>
    <Instrument program="101">FX 6 (goblins)</Instrument>
    <Instrument program="102">FX 7 (echoes)</Instrument>
    <Instrument program="103">FX 8 (sci-fi)</Instrument>
  </SynthEffects>
  <Ethnic>
    <Instrument program="104">Sitar</Instrument>
    <Instrument program="105">Banjo</Instrument>
    <Instrument program="106">Shamisen</Instrument>
    <Instrument program="107">Koto</Instrument>
    <Instrument program="108">Kalimba</Instrument>
    <Instrument program="109">Bagpipe</Instrument>
    <Instrument program="110">Fiddle</Instrument>
    <Instrument program="111">Shanai</Instrument>
  </Ethnic>
  <Percussive>
    <Instrument program="112">Tinkle Bell</Instrument>
    <Instrument program="113">Agogo</Instrument>
    <Instrument program="114">Steel Drums</Instrument>
    <Instrument program="115">Woodblock</Instrument>
    <Instrument program="116">Taiko Drum</Instrument>
    <Instrument program="117">Melodic Tom</Instrument>
    <Instrument program="118">Synth Drum</Instrument>
    <Instrument program="119">Reverse Cymbal</Instrument>
  </Percussive>
  <SoundEffects>
    <Instrument program="120">Guitar Fret Noise</Instrument>
    <Instrument program="121">Breath Noise</Instrument>
    <Instrument program="122">Seashore</Instrument>
    <Instrument program="123">Bird Tweet</Instrument>
    <Instrument program="124">Telephone Ring</Instrument>
    <Instrument program="125">Helicopter</Instrument>
    <Instrument program="126">Applause</Instrument>
    <Instrument program="127">Gunshot</Instrument>
  </SoundEffects>
  <DrumKits channel="9">
    <Kit program="0">Standard Kit</Kit>
    <Kit program="1">Room Kit</Kit>
    <Kit program="2">Power Kit</Kit>
    <Kit program="3">Electronic Kit</Kit>
    <Kit program="4">TR-808 Kit</Kit>
    <Kit program="5">Jazz Kit</Kit>
    <Kit program="6">Brush Kit</Kit>
    <Kit program="7">Orchestra Kit</Kit>
    <Kit program="8">SFX Kit</Kit>
  </DrumKits>
</GeneralMIDIInstruments>
'''

pretty_midi_docs = """
pretty_midi contains utility function/classes for handling MIDI data in an easily manipulable format.

Key Classes:
1. PrettyMIDI(midi_file=None, resolution=220, initial_tempo=120.0)
   - instruments: List of Instrument objects
   - get_end_time(): Returns time in seconds where MIDI file ends
   - write(filename): Write MIDI data to file
   - get_tempo_changes(): Returns tempo change times and tempos

2. Instrument(program, is_drum=False, name='')
   - program: MIDI program number (0-127)
   - is_drum: Boolean for drum tracks (channel 9)
   - notes: List of Note objects
   - Add to MIDI with: midi.instruments.append(instrument)

3. Note(velocity, pitch, start, end)
   - velocity: Note velocity (0-127)
   - pitch: MIDI note number
   - start: Note start time in seconds
   - end: Note end time in seconds
   - Add to instrument with: instrument.notes.append(note)

Key Utility Functions:
- note_name_to_number(note_name): Converts note name (e.g. 'C4') to MIDI number
- note_number_to_name(note_number): Converts MIDI number to note name
- instrument_name_to_program(name): Converts instrument name to program number

IMPORTANT: Never use midi.initial_tempo to get the tempo. Always use:
bpm = midi.get_tempo_changes()[1][0] if len(midi.get_tempo_changes()[1]) > 0 else 120
beat_length = 60.0 / bpm

Example for creating a simple MIDI file:
```python
import pretty_midi

# Create a PrettyMIDI object
midi = pretty_midi.PrettyMIDI()

# Set tempo
bpm = midi.get_tempo_changes()[1][0] if len(midi.get_tempo_changes()[1]) > 0 else 120
beat_length = 60.0 / bpm

# Create instrument
piano = pretty_midi.Instrument(program=0)  # Piano

# Create notes from note names
note_names = ['C4', 'E4', 'G4']
for i, name in enumerate(note_names):
    # Convert note name to number
    pitch = pretty_midi.note_name_to_number(name)
    # Create a Note with start and end times in seconds
    note = pretty_midi.Note(velocity=100, pitch=pitch, start=i*beat_length, end=i*beat_length+0.4)
    # Add note to instrument
    piano.notes.append(note)

# Add instrument to MIDI
midi.instruments.append(piano)

# Write to file
midi.write('output.mid')
```

Example for loading and modifying a MIDI file:
```python
import pretty_midi

# Load MIDI file
midi = pretty_midi.PrettyMIDI('input.mid')

# Get timing info
bpm = midi.get_tempo_changes()[1][0] if len(midi.get_tempo_changes()[1]) > 0 else 120
beat_length = 60.0 / bpm

# Add a new instrument
bass = pretty_midi.Instrument(program=33)  # Electric bass

# Create a bass line
bass_pitches = [36, 38, 40, 41]  # C2, D2, E2, F2
for i, pitch in enumerate(bass_pitches):
    start = i * beat_length
    end = start + 0.9 * beat_length
    note = pretty_midi.Note(velocity=80, pitch=pitch, start=start, end=end)
    bass.notes.append(note)

# Add to MIDI
midi.instruments.append(bass)

# Save modified file
midi.write('output.mid')
```

CRITICAL NOTES:
1. NEVER use 'bank' parameter in Instrument() constructor
2. For drums, use program=0, is_drum=True
3. For note creation, ALWAYS convert note names to numbers with note_name_to_number()
4. Don't forget to append instruments to midi.instruments after creating them
5. NEVER use midi.initial_tempo. Always use midi.get_tempo_changes() to get the tempo.
"""

# ================================
# SYSTEM PROMPT
# ================================
system_prompt = f"""
You are a creative music agent specialized in creating MIDI loops in various musical styles, using instruments from the General MIDI SoundFont.
Your primary responsibility is to generate, analyze, and iteratively improve music to maximize pleasantness and authenticity.

REFERENCE INSTRUMENT LIST:
{instrument_list}

REFERENCE: The General MIDI instrument list provides authentic instrument, detuning, and arrangement details for each track. Leverage this knowledge to create authentic-sounding music.

TECHNICAL EXPERTISE: You are proficient with the pretty_midi Python library for creating MIDI files.

TIMING ALIGNMENT RULES (EXTREMELY IMPORTANT):
1. ALWAYS use a "bar-beat-grid" approach: All notes MUST be placed on a consistent grid defined by:
   - Bars (4 beats per bar in 4/4 time)
   - Beats (quarter notes)
   - Sub-beats (8th or 16th notes)

2. The GOLDEN RULE: All instruments must reference the SAME timing variables:
   ```python
   # These variables must be computed first and used for ALL instruments
   bpm = 120  # Or another appropriate tempo
   beat_length = 60.0 / bpm
   bar_length = 4 * beat_length  # 4 beats per bar (4/4 time)
   ```

3. Instrument patterns must be created using bar and beat indices, NOT arbitrary time offsets:
   ```python
   # CORRECT - using bar and beat indices:
   for bar in range(num_bars):
       for beat in range(4):  # 4 beats per bar
           time = bar * bar_length + beat * beat_length
           # Add notes at this time
   ```

4. When extending or doubling MIDI length, ALL instruments must extend by the exact same amount:
   ```python
   # CORRECT approach:
   original_duration = midi.get_end_time()
   for instrument in midi.instruments:
       original_notes = instrument.notes.copy()
       for note in original_notes:
           new_note = pretty_midi.Note(
               velocity=note.velocity,
               pitch=note.pitch,
               start=note.start + original_duration,  # Same duration for ALL
               end=note.end + original_duration       # Same duration for ALL
           )
           instrument.notes.append(new_note)
   ```

5. ALL instruments must have the SAME underlying rhythm structure. If one changes, ALL must change.

FAILURE MODES TO AVOID:
1. Different timing variables for different instruments
2. Arbitrary time offsets instead of bar-beat indexing
3. Different patterns/loops with different lengths
4. Excessive randomization of timing
5. Unpredictable note placements (outside the grid)

You're expected to prioritize musical enjoyment over complexity. Starting simple and building complexity gradually is key.
"""

# ================================
# COMPOSITION PROMPT
# ================================
compose_prompt_template = '''
YOUR RESPONSE MUST BE ONLY THE PYTHON CODE, WRAPPED IN <CODE>...</CODE> TAGS. NO OTHER EXPLANATORY TEXT BEFORE OR AFTER THE CODE BLOCK.

TASK: Create Python code to generate a complete musical loop in the {style} style.

AVAILABLE INSTRUMENTS:
''' + instrument_list + '''

PRETTY_MIDI REFERENCE DOCUMENTATION:
''' + pretty_midi_docs + '''

# ===== CRITICAL TIMING FRAMEWORK =====
FOLLOW THIS EXACT FRAMEWORK for ALL music creation:

```python
import os
output_path = os.environ['OUTPUT_PATH']
import pretty_midi
import numpy as np
import random

# === STEP 1: Set up basic parameters ===
bpm = 120  # Set appropriate tempo for {style}
beat_length = 60.0 / bpm  # Duration of one beat in seconds
bar_length = 4 * beat_length  # 4/4 time signature
num_bars = 4  # Start with 4 bars for first iteration

# === STEP 2: Create the MIDI object ===
midi = pretty_midi.PrettyMIDI()

# === STEP 3: Set up your instruments ===
# Define ALL instruments first before adding notes
instruments = []  # Store all instruments here

# Example instrument setup:
bass = pretty_midi.Instrument(program=33)  # Electric bass
drums = pretty_midi.Instrument(program=0, is_drum=True)
# Add more instruments as needed...

instruments.extend([bass, drums])  # Add all instruments to this list

# === STEP 4: Set up musical parameters ===
# Define key, scale, chord progression here
root_note = 60  # C4 (middle C)
# For minor: [0, 2, 3, 5, 7, 8, 10]
# For major: [0, 2, 4, 5, 7, 9, 11]
scale_intervals = [0, 2, 3, 5, 7, 8, 10]  # Minor scale intervals
# Create a scale from the root note
scale = [root_note + interval for interval in scale_intervals]
# Add octaves above and below
full_scale = []
for octave in [-1, 0, 1]:
    full_scale.extend([note + (12 * octave) for note in scale])

# === STEP 5: Create a bar-beat grid and add notes ===
# CRITICAL: ALL instruments MUST use this same grid
for bar in range(num_bars):
    # For each bar (4 beats per bar)
    for beat in range(4):
        # Calculate the exact time position
        time = bar * bar_length + beat * beat_length
        
        # Add drums at this position (example)
        if beat == 0:  # Kick on beat 1
            drums.notes.append(pretty_midi.Note(
                velocity=100, 
                pitch=36,  # Bass drum
                start=time, 
                end=time + 0.1
            ))
        
        # Add bass notes at this position (example)
        if beat == 0 or beat == 2:  # Bass on beats 1 and 3
            bass_note = scale[0] - 24  # Root note, 2 octaves down
            bass.notes.append(pretty_midi.Note(
                velocity=90,
                pitch=bass_note,
                start=time,
                end=time + beat_length * 0.8  # Slightly detached
            ))

# === STEP 6: Add instruments to MIDI ===
# Add ALL defined instruments to the MIDI object
for instrument in instruments:
    midi.instruments.append(instrument)

# === STEP 7: Save the MIDI file ===
midi.write(output_path)
```

INSTRUCTIONS:
1. Follow the EXACT FRAMEWORK provided above.
2. Choose appropriate instruments for {style} using the instrument list.
3. CRITICAL: ALL instruments must use the SAME bar-beat grid system.
4. Follow these placement rules:
   - Drums/percussion should use the standard General MIDI drum map
   - Bass should follow the chord progression or root notes
   - Lead instruments should play melody within the scale
   - Harmony instruments should use chords from the progression

5. SIMPLICITY is CRITICAL for the first iteration:
   - Use only 1-3 instruments
   - Keep rhythms straightforward and repetitive
   - Use a simple 4-bar loop with a clear beat
   - Ensure all instruments start and end at bar boundaries

6. ALWAYS save to the path specified by the environment variable:
   ```python
   import os
   output_path = os.environ['OUTPUT_PATH']
   ```

SUCCESS CRITERIA:
- Code is executable Python with no syntax errors
- Notes for all instruments align perfectly to the bar-beat grid
- Music follows established conventions for {style}
- All instruments play for the entire duration
- Output is saved to the correct path

IMPORTANT: For this first iteration, use only one instrument (e.g., piano, bass, or drums). Focus on a clear, memorable motif or rhythm. Make it catchy, clear, and easy to follow.

FINAL AND ABSOLUTELY CRITICAL REMINDER: YOUR RESPONSE MUST BE *ONLY* THE PYTHON CODE, WRAPPED IN `<CODE>...</CODE>` TAGS. NO OTHER TEXT, NO EXPLANATIONS, NO INTRODUCTIONS, NO SUMMARIES. JUST THE CODE BLOCK.
'''

# ================================
# MUTATION PROMPT
# ================================
mutate_prompt_template = f"""
TASK: Transform and enhance the existing music based on feedback and {{style}} genre characteristics.

CURRENT SONG:
- File: {{midi_path}}
- Style: {{style}}

ANALYSIS OF CURRENT SONG:
{{analysis}}

ORIGINAL CODE FROM PREVIOUS ITERATION:
<CODE>
{{previous_code}}
</CODE>

AVAILABLE INSTRUMENTS:
{instrument_list}

PRETTY_MIDI REFERENCE DOCUMENTATION:
{pretty_midi_docs}

# ===== PERFECT TIMING FRAMEWORK =====
FOLLOW THIS EXACT FRAMEWORK for extending/enhancing music:

     ```python
import os
output_path = os.environ['OUTPUT_PATH']
import pretty_midi
import numpy as np
import random

# === STEP 1: Load the existing MIDI file ===
midi_path = '{{midi_path}}'
midi = pretty_midi.PrettyMIDI(midi_path)

# === STEP 2: Extract timing information ===
# Ensure we use the existing tempo
bpm = midi.get_tempo_changes()[1][0] if len(midi.get_tempo_changes()[1]) > 0 else 120
beat_length = 60.0 / bpm
bar_length = 4 * beat_length  # Assuming 4/4 time signature
loop_duration = midi.get_end_time() # Raw end time
num_bars = int(round(loop_duration / bar_length)) # Calculate num_bars robustly
exact_loop_duration_for_doubling = num_bars * bar_length # CRITICAL: Use this for precise doubling

# === STEP 3: Identify existing instruments ===
# Always inspect what's already in the MIDI file
existing_instruments = midi.instruments
has_drums = any(inst.is_drum for inst in existing_instruments)
has_bass = any(32 <= inst.program <= 39 for inst in existing_instruments)
instrument_count = len(existing_instruments)
total_bars_after_doubling = num_bars * 2

# === STEP 4: DOUBLE THE LENGTH (copy everything forward) ===
# Apply to ALL instruments consistently using the exact calculated duration
for instrument in midi.instruments:
    original_notes = instrument.notes.copy()
    for note in original_notes:
        # Create a new note copy, shifted by exact original duration
        new_note = pretty_midi.Note(
            velocity=note.velocity,
            pitch=note.pitch,
            start=note.start + exact_loop_duration_for_doubling,
            end=note.end + exact_loop_duration_for_doubling
        )
        instrument.notes.append(new_note)

# === STEP 5: Add new instruments OR enhance existing ones ===
# New instruments must follow the EXACT SAME bar-beat grid and span total_bars_after_doubling
# Example of how to add a new instrument (e.g., a synth lead):
# synth_lead = pretty_midi.Instrument(program=81) # Lead 2 (sawtooth)
# for bar in range(total_bars_after_doubling):
#     for beat in range(4): # Assuming 4 beats per bar
#         time = bar * bar_length + beat * beat_length
#         # Add notes for synth_lead, ensuring they use 'time', 'beat_length'
#         # and the new part spans all 'total_bars_after_doubling'
# if synth_lead.notes: # Only add if notes were actually added
#    midi.instruments.append(synth_lead)

# Example of how to enhance an existing drum track (if drums exist)
# drum_instrument = next((inst for inst in midi.instruments if inst.is_drum), None)
# if drum_instrument:
#     for bar in range(total_bars_after_doubling):
#         # Add new drum notes (e.g. a cymbal pattern) for the entire new duration
#         # Ensure to use 'bar * bar_length + beat * beat_length' for timing
#         pass # Replace with actual note adding logic

# === STEP 6: Save the modified MIDI file ===
midi.write(output_path)
```

INSTRUCTIONS:
0. **MANDATORY ADHERENCE TO FRAMEWORK**: The Python code framework provided above under "# ===== PERFECT TIMING FRAMEWORK =====" is NOT a suggestion. It is a STRICT TEMPLATE. You MUST follow its structure, variable names (`bpm`, `beat_length`, `bar_length`, `num_bars`, `exact_loop_duration_for_doubling`, `total_bars_after_doubling`), and logic for ALL timing calculations, song doubling, and instrument part generation. DEVIATION WILL LEAD TO TIMING ERRORS.
1. ALWAYS follow the EXACT FRAMEWORK above to ensure perfect timing.
2. CRITICAL: With each mutation, you MUST DOUBLE the length of the song from the previous iteration using `exact_loop_duration_for_doubling` as the offset for copied notes. The new total length will be `total_bars_after_doubling`.
3. Follow these TIMING RULES exactly:
   - ALWAYS use the bar-beat grid system based on the `bpm`, `beat_length`, and `bar_length` calculated in STEP 2.
   - NEVER add arbitrary time offsets to notes. All note `start` and `end` times MUST be calculated relative to `bar * bar_length + beat * beat_length` (or sub-beat divisions thereof).
   - ALL instruments (existing and new) must operate on this single, unified timing grid.
   - NEW instruments must follow the SAME bar-beat grid as existing ones.
   - ALL new notes must align PERFECTLY to beat divisions.

4. When enhancing the song:
   - First, CRITICALLY, ensure the entire song's length is doubled using the `exact_loop_duration_for_doubling` for note offsets, as shown in STEP 4. The song will now span `total_bars_after_doubling`.
   - Then, add 1-2 NEW instruments or create NEW patterns for existing instruments.
   - **CRUCIAL FOR COHESION**: Any NEW instrument patterns or ENHANCEMENTS to existing instruments MUST be written to span the **ENTIRE new `total_bars_after_doubling` duration**.
   - AVOID adding new musical material that only exists for a small fraction of the `total_bars_after_doubling`. The goal is to extend the *whole song* cohesively.
   - New musical parts should complement the existing (doubled) parts rhythmically and harmonically across the entire `total_bars_after_doubling`.
   - Maintain consistent motifs and patterns within each instrument across the `total_bars_after_doubling`, unless you are consciously evolving the pattern throughout the entire new length.
   
5. THINK LIKE A COMPOSER FOR THE FULL (`total_bars_after_doubling`) LENGTH:
   - ALL instruments MUST adhere to the same global `bpm`, `beat_length`, and `bar_length`. All note placements must use the shared bar-beat grid.
   - When the song length is doubled to `total_bars_after_doubling`, ensure that any new musical ideas (new instruments, new patterns for existing instruments) are developed to span this **entire `total_bars_after_doubling` duration**.
   - Bass lines should provide a foundation for the chord progression across all `total_bars_after_doubling`.
   - Drum patterns should provide a consistent rhythmic framework for all `total_bars_after_doubling`.
   - Melodies and harmonies should relate to the scale and chords across all `total_bars_after_doubling`.
   - Strive for a balanced and cohesive musical experience throughout the entire extended piece.

6. AVOID THESE COMMON MISTAKES:
   - **Re-calculating or defining new `bpm`, `beat_length`, or `bar_length` variables when adding new parts. ALWAYS use the globally defined ones from STEP 2 of the framework.**
   - Using `midi.get_end_time()` or `loop_duration` directly as the offset for doubling notes. ALWAYS use `exact_loop_duration_for_doubling` (calculated as `num_bars * bar_length`) for perfect alignment as shown in STEP 4.
   - Different timing logic or independent timing loops for different instruments.
   - Instruments with different pattern lengths that don't span `total_bars_after_doubling`.
   - Random or arbitrary time placements not tied to the `bar * bar_length + beat * beat_length` grid.
   - Using note strings instead of MIDI note numbers.
   - Forgetting to append new instruments to `midi.instruments`.

7. VALIDATION: Always check your timing logic by verifying:
   - All instruments use the same `bpm`, `bar_length` and `beat_length` variables defined in STEP 2.
   - All notes are placed using the `bar * bar_length + beat * beat_length` grid system.
   - The new song length (i.e., `midi.get_end_time()` after all modifications) is approximately `exact_loop_duration_for_doubling * 2` (or `total_bars_after_doubling * bar_length`).
   - All new instrument parts are written to span the full `total_bars_after_doubling`.

SUCCESS CRITERIA:
- Code doubles the length of the song perfectly using `exact_loop_duration_for_doubling`.
- All instruments (original, copied, and new) remain perfectly synchronized on the shared timing grid.
- New instruments and patterns complement existing ones and span the entire `total_bars_after_doubling`.
- All notes align to the bar-beat grid.
- Code is executable with no errors.
- The file is saved to the specified output_path.

RETURN ONLY the Python code, wrapped in `<CODE>...</CODE>` tags.
"""

# ================================
# REFACTORING PROMPT
# ================================
refactor_prompt_template = f"""
TASK: Fix the code that failed to execute or had timing issues.

ERROR INFORMATION:
{{error}}

ORIGINAL CODE:
<CODE>
{{previous_code}}
</CODE>

PRETTY_MIDI REFERENCE DOCUMENTATION:
{pretty_midi_docs}

CRITICAL TIMING PROBLEMS TO FIX:
1. Check for reference to undefined variables (especially midi.initial_tempo)
2. Verify all instruments use the SAME timing variables (bpm, beat_length, bar_length)
3. Ensure no arbitrary time offsets are used - all notes should align to a beat grid
4. Check for instruments or notes created but not properly added to the MIDI object
5. Ensure all instruments have a consistent pattern length and are aligned to bar boundaries

THE PERFECT PATTERN:
   ```python
# All music creation must follow this standard pattern
import os
output_path = os.environ['OUTPUT_PATH']
   import pretty_midi

# Set timing parameters ONE time for ALL instruments
bpm = 120  # or another appropriate value
beat_length = 60.0 / bpm
bar_length = 4 * beat_length  # 4 beats per bar in 4/4 time

# Create instruments before adding any notes
bass = pretty_midi.Instrument(program=33)  # Electric bass
drums = pretty_midi.Instrument(program=0, is_drum=True)

# Use a bar-beat grid for ALL instruments
for bar in range(4):  # Number of bars
    for beat in range(4):  # 4 beats per bar
        time = bar * bar_length + beat * beat_length
        
        # Add notes for ALL instruments referenced to this same grid
        if beat == 0:  # On downbeat
            bass.notes.append(pretty_midi.Note(
                velocity=100,
                pitch=40,  # E2
                start=time,
                end=time + beat_length * 0.8
            ))
            
            drums.notes.append(pretty_midi.Note(
                velocity=100,
                pitch=36,  # Kick drum
                start=time,
                end=time + 0.1
            ))

# Add ALL instruments to the MIDI file
midi = pretty_midi.PrettyMIDI()
midi.instruments.append(bass)
midi.instruments.append(drums)

# Save the file
   midi.write(output_path)
   ```

GUIDELINES FOR FIXING:
1. Keep the musical intent of the original code, but fix ALL timing issues
2. Make sure ALL instruments use the SAME timing variables and grid system
3. Remove any references to undefined variables (e.g., midi.initial_tempo)
4. Ensure all notes are positioned using bar-beat grid logic, NOT arbitrary offsets
5. Verify that ALL instruments and notes are properly added to the MIDI object
6. Create a central timing system that ALL instruments follow.
RETURN ONLY the fixed Python code, wrapped in `<CODE>...</CODE>` tags.

"""

improve_prompt_template = """
Given the following Python code for generating MIDI music and the validator's feedback, revise the code to address the issues and improve musical coherence.

Original code:
<CODE>
{original_code}
</CODE>

Validator feedback:
{validator_feedback}

Return ONLY the revised code in a <CODE>...</CODE> block.
""" 